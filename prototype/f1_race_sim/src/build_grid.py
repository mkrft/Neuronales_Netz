"""
    Module to start-up the grid and create
    all according and needed car objects with
    their drivers.

    Drivers will be generated by default names without
    using real names.
"""

#=====Imports=========================================
import random

#=====Module Imports==================================
from src.config import (
    NUMBER_OF_COMPETITORS,
    RACE_START_OFFSET
)
from src.const import (
    SEPERATION_FACTOR,
    DEFAULT_DRIVER_NAME, 
    DEFAULT_DRIVER_SHORT,
    HARD,
    MEDIUM,
    SOFT
)

from src.cars import Car
from src.drivers import Driver
from src.tyre import Tyre
from src.order_grid import order_grid

#=====Libraries=======================================


#=====Functions=======================================
def build_grid():
    """
    Generate all necessary drivers and cars
    Save according information to the grid#

    TODO
        - How to set different skill levels? Now default
        - How to set different car power levels, but same for two cars from same "team"
        - How to give different cars different tyres
    """

    # Init our grid
    grid = []
    

    # Generate a list of all possible grid positions
    # and devide it in certain start ranges
    pos_start = list(range(1, NUMBER_OF_COMPETITORS + 1))

    possible_start_pos = []
    for x in range(0, len(pos_start), SEPERATION_FACTOR):
        possible_start_pos.append(pos_start[x : x + SEPERATION_FACTOR])


    # Generate a starting grid
    for i in range(NUMBER_OF_COMPETITORS):


        # Start to deploy the skill / power levels dynamically
        # TODO Eval there skill / power models
        # The difference should not be to big, otherwise we get the same result everytime :D
        # Still showing that overtaking is too easy right now
        skill = round(1 - i / 21, 3)
        if i % 2 == 0:
            power = round(1 - i / 21, 3)


        # Calc starting position
        starting_pos, possible_start_pos = start_pos_generator(skill, power, possible_start_pos)


        # Make sure there are only three letters
        # per driver short
        if i < 9:
            driver_number = "0" + f"{i+1}"
        else:
            driver_number = f"{i+1}"

        driver = Driver(
            name=DEFAULT_DRIVER_NAME + driver_number,
            short=DEFAULT_DRIVER_SHORT + driver_number,
            skill=skill
        )

        tyre = Tyre(compound=SOFT)

        car = Car(
            driver=driver,
            power=power,
            tyre=tyre,
            position=starting_pos,
            grid_position=starting_pos,
            used_tyres=[tyre.compound]
        )

        grid.append(car)
    

    # Order the grid concerning their grid positions
    grid = sorted(grid, key=lambda car: car.grid_position)

    # Now apply the race start offset
    # To seperate the field in the beginning
    for index,car in enumerate(grid):
        car.race_time += index * RACE_START_OFFSET
        car.delta_to_leader += index * RACE_START_OFFSET
        car.delta_to_car_infront += RACE_START_OFFSET if index is not 0 else 0

    return grid


def start_pos_generator(skill, power, possible_start_pos):
    """
    Generate a start position based on the skill and power of a driver
    if the position is already given, choose a different one

    param - {float} - skill
    param - {float} - power
    param - {list[int]} - possible_start_pos

    return - {int} - starting_pos
    return - {list[list[int]]} - possible_start_pos
    
    """

    # Max of skill and power summed is 2, so we need the factor that normalizes them to the SEPERATION_FACTOR
    # the resulting factor shall define the index in which will be searched for the starting position
    # add 0.001 to allow skill = 0 and power = 0 to work
    start_range_index = int((len(possible_start_pos) - 1) - (((skill + power + 0.0001) * len(possible_start_pos)/ 2) - 1))

    # Prevent error from happening by incrementing the index
    while possible_start_pos[start_range_index] == []:
        start_range_index += 1

    # Choose a random elements within the given range of starting positions
    starting_pos = random.choice(possible_start_pos[start_range_index])

    # Now delete the starting pos that will be given away from the given subset
    possible_start_pos[start_range_index].remove(starting_pos)

    return starting_pos, possible_start_pos

